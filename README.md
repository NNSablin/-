# Домашнее задание к занятию "`Базы данных, их типы`" - `Саблин Никита`


### Инструкция по выполнению домашнего задания

   1. Сделайте `fork` данного репозитория к себе в Github и переименуйте его по названию или номеру занятия, например, https://github.com/имя-вашего-репозитория/git-hw или  https://github.com/имя-вашего-репозитория/7-1-ansible-hw).
   2. Выполните клонирование данного репозитория к себе на ПК с помощью команды `git clone`.
   3. Выполните домашнее задание и заполните у себя локально этот файл README.md:
      - впишите вверху название занятия и вашу фамилию и имя
      - в каждом задании добавьте решение в требуемом виде (текст/код/скриншоты/ссылка)
      - для корректного добавления скриншотов воспользуйтесь [инструкцией "Как вставить скриншот в шаблон с решением](https://github.com/netology-code/sys-pattern-homework/blob/main/screen-instruction.md)
      - при оформлении используйте возможности языка разметки md (коротко об этом можно посмотреть в [инструкции  по MarkDown](https://github.com/netology-code/sys-pattern-homework/blob/main/md-instruction.md))
   4. После завершения работы над домашним заданием сделайте коммит (`git commit -m "comment"`) и отправьте его на Github (`git push origin`);
   5. Для проверки домашнего задания преподавателем в личном кабинете прикрепите и отправьте ссылку на решение в виде md-файла в вашем Github.
   6. Любые вопросы по выполнению заданий спрашивайте в чате учебной группы и/или в разделе “Вопросы по заданию” в личном кабинете.
   
Желаем успехов в выполнении домашнего задания!
   
### Дополнительные материалы, которые могут быть полезны для выполнения задания

1. [Руководство по оформлению Markdown файлов](https://gist.github.com/Jekins/2bf2d0638163f1294637#Code)

---

### Задание 1

Для решения задач строительной компании можно рассмотреть следующие типы СУБД, учитывая их особенности и требования к каждому направлению.

### 1.1. Бюджетирование проектов и аналитика
**Тип СУБД:** Реляционная (например, PostgreSQL или Oracle).
**Причина:** Реляционные СУБД обеспечивают строгую структуру данных, целостность и поддержку сложных транзакций. Они подходят для финансовых расчётов, формирования отчётов и прогнозирования рисков благодаря возможности выполнения сложных SQL-запросов и интеграции с BI-системами. 

**Ускорение хеширования:** Для ускорения хеширования можно использовать аппаратные ускорители (например, GPU или специализированные микросхемы для криптографических операций) или оптимизировать алгоритмы хеширования. Также стоит рассмотреть использование библиотек, оптимизированных для параллельных вычислений, например, OpenSSL с поддержкой многопоточности. Если хеширование выполняется в рамках СУБД, можно настроить параметры буферизации и кэширования для снижения нагрузки.

### 1.2. Лендинги и CRM
**Для лендингов:** Документная СУБД (например, MongoDB).
**Причина:** Лендинги часто работают с неструктурированными или полуструктурированными данными (контент, медиафайлы). Документные СУБД позволяют гибко хранить данные в формате JSON, что упрощает разработку и масштабирование. 

**Для CRM:** Реляционная СУБД (например, PostgreSQL или MySQL).
**Причина:** CRM-системы требуют сложных аналитических запросов, транзакционной целостности и интеграции с другими системами. Реляционные СУБД обеспечивают надёжность и поддержку сложных операций. 

**Использование одной СУБД:** Теоретически можно использовать одну СУБД (например, MongoDB) для обеих задач, если готова работать с гибкой схемой. Однако для CRM может потребоваться дополнительная настройка для обеспечения транзакционной целостности и сложных аналитических возможностей. Комбинация СУБД (например, MongoDB для лендингов и PostgreSQL для CRM) может обеспечить баланс между гибкостью и функциональностью.

### 1.3. База корпоративных норм и правил
**Тип СУБД:** Реляционная (например, PostgreSQL).
**Причина:** Реляционные СУБД подходят для хранения структурированных данных с чёткими связями и иерархией. Они обеспечивают простоту в управлении и понятный интерфейс для работы с данными.

**Использование существующей СУБД:** Можно использовать ту же реляционную СУБД, что и для бюджетирования (например, PostgreSQL). Это упростит интеграцию и администрирование.

### 1.4. Логистика и распределение курьеров
**Тип СУБД:** Графовая (например, Neo4j) или реляционная с поддержкой сложных связей (PostgreSQL).
**Причина:** Графовые СУБД эффективно работают с данными, имеющими сложные взаимосвязи, что важно для построения маршрутов и распределения ресурсов. Если требуется интеграция с другими системами, можно использовать PostgreSQL с расширениями для работы с графами.

**Подключение отдела закупок:** Можно подключить отдел закупок к той же СУБД, если задачи связаны с логистикой (например, управление поставками). Однако если у отдела закупок есть специфические требования (например, сложные транзакции или необходимость интеграции с ERP-системами), может потребоваться отдельная СУБД.

### 1.5. Единая СУБД для всех задач
**Возможность:** Теоретически можно использовать одну СУБД (например, PostgreSQL), так как она поддерживает различные типы данных и расширения. Однако это может привести к компромиссам в производительности и функциональности для некоторых задач (например, для графовых запросов или работы с неструктурированными данными).

**Рекомендации:**
- Для большинства задач подойдёт PostgreSQL благодаря гибкости и поддержке расширений.
- Для лендингов можно использовать MongoDB в качестве дополнительной СУБД для хранения неструктурированных данных.
- Для логистики рассмотреть графовые расширения или отдельную графовую СУБД.

**Вывод:** Оптимальным решением может быть комбинация специализированных СУБД для разных задач, что позволит достичь максимальной эффективности и производительности. Например, PostgreSQL для бюджетирования, CRM и базы норм, MongoDB для лендингов, Neo4j для логистики. Это обеспечит баланс между функциональностью, масштабируемостью и простотой администрирования.

Если у вас есть дополнительные требования или ограничения (например, бюджет, интеграция с существующими системами), уточните их — это поможет дать более точные рекомендации.

### Задание 2

### 2.1. Пополнение баланса телефона (ручное выполнение)


Пошаговая последовательность действий для успешной транзакции:


1. **Инициализация операции**  
Пользователь выбирает способ пополнения (мобильное приложение, терминал, сайт оператора и т. п.) и вводит номер телефона, сумму платежа, реквизиты платёжного средства (карты, электронного кошелька).


2. **Проверка данных и авторизация**  
Система проверяет корректность введённых данных (номер телефона, сумма, реквизиты карты). Если используется карта, выполняется запрос на авторизацию в банк‑эмитент для подтверждения достаточности средств и права на операцию.

3. **Резервирование средств**  
На счёте платёжного инструмента (карты, кошелька) резервируется сумма пополнения (холдирование). Это гарантирует, что средства не будут потрачены на другие операции до завершения транзакции.
4. **Взаимодействие с биллинговой системой оператора**  
Система платежа отправляет запрос в биллинговую систему мобильного оператора с данными о платеже (номер, сумма, идентификатор транзакции). Оператор проверяет номер на активность и допустимость пополнения.
5. **Фиксация платежа и обновление баланса**  
При успешном ответе от биллинговой системы:  
- средства списываются с платёжного инструмента;  
- баланс телефона увеличивается на указанную сумму;  
- генерируется уникальный номер транзакции и сохраняется в журналах обеих систем.
6. **Уведомление пользователя**  
Пользователь получает подтверждение (SMS, push‑уведомление, экранный месседж) с деталями платежа: сумма, новый баланс, номер транзакции.

**Критические точки:**  
- Если на любом шаге возникает ошибка (недостаточно средств, сбой связи, неверный номер), транзакция откатывается: зарезервированные средства разблокируются, баланс не изменяется, пользователь получает уведомление об ошибке.

---

### 2.1*. Пополнение через автоплатёж

При автоплатеже последовательность отличается автоматизацией и триггерами:


1. **Мониторинг баланса**  
Система регулярно (или в режиме реального времени) проверяет текущий баланс указанного номера телефона. Триггер — достижение порога, заданного пользователем (например, ≤ 30 руб.).
2. **Активация автоплатежа**  
При срабатывании триггера система автоматически извлекает из настроек:  
- сумму пополнения (фиксированная или динамическая);  
- платёжное средство (карта, кошелёк), привязанное к сервису автоплатежей.
3. **Авторизация и резервирование**  
Выполняется запрос на авторизацию платежа по сохранённым реквизитам. Средства резервируются на счёте платёжного инструмента.
4. **Взаимодействие с биллингом оператора**  
Запрос на пополнение отправляется в биллинговую систему оператора. Оператор подтверждает приём платежа и готовность обновить баланс.
5. **Списание и обновление баланса**  
- Средства окончательно списываются с платёжного инструмента;  
- Баланс телефона увеличивается;  
- Транзакция фиксируется в системах платежа и оператора.
6. **Уведомление (опционально)**  
Пользователь может получить уведомление о выполнении автоплатежа (SMS, push, email), если это настроено в параметрах сервиса.

**Особенности автоплатежа:**  
- **Периодичность:** может быть событийной (по порогу баланса) или календарной (раз в месяц).  
- **Безопасность:** платёжные реквизиты хранятся в зашифрованном виде, а операции подписываются токенами/одноразовыми кодами.  
- **Отказоустойчивость:** при ошибке (например, заблокированная карта) система повторяет попытку через заданный интервал или уведомляет пользователя для ручного вмешательства.  
- **Гибкость:** пользователь может изменить сумму, порог баланса или отключить автоплатёж в любой момент.

### Задание 3

### 3.1. Пять преимуществ SQL‑систем перед NoSQL

1. **Строгая согласованность данных (ACID‑гарантии)**  
SQL‑системы обеспечивают выполнение свойств ACID (Atomicity, Consistency, Isolation, Durability):  
- транзакция либо полностью завершается, либо откатывается;  
- данные всегда остаются в согласованном состоянии;  
- параллельные транзакции не мешают друг другу;  
- изменения сохраняются навсегда после подтверждения.  
Это критично для финансов, учёта и других сценариев, где недопустимы расхождения.

2. **Чёткая схема данных (фиксированная структура)**  
В SQL заранее определяется схема БД (таблицы, столбцы, типы, ограничения). Это:  
- предотвращает ошибки ввода;  
- облегчает понимание структуры для разработчиков и аналитиков;  
- гарантирует, что все записи соответствуют заданным правилам.  
NoSQL, напротив, часто допускает свободную схему, что повышает риск неконсистентности.

3. **Мощный декларативный язык запросов (SQL)**  
SQL позволяет:  
- извлекать сложные наборы данных с помощью одного запроса;  
- объединять таблицы (JOIN), группировать, фильтровать, агрегировать;  
- писать читаемые и поддерживаемые запросы.  
В NoSQL зачастую нужны программные обходы или специфические языки запросов, менее выразительные по сравнению с SQL.

4. **Развитая экосистема и стандартизация**  
- SQL — международный стандарт (ISO/IEC 9075), поддерживаемый всеми реляционными СУБД;  
- огромное количество инструментов: ORM (Hibernate, Entity Framework), BI‑системы (Tableau, Power BI), ETL, мониторинги;  
- обилие документации, обучающих материалов, сообществ и специалистов.  
NoSQL‑системы чаще проприетарны или имеют фрагментированные стандарты, что усложняет интеграцию и поддержку.

5. **Надёжность и транзакционная целостность**  
SQL‑СУБД проектировались для критичных приложений (банки, ERP, CRM), поэтому:  
- имеют проверенные механизмы репликации и восстановления;  
- поддерживают сложные ограничения (UNIQUE, FOREIGN KEY, CHECK);  
- обеспечивают изоляцию транзакций на разных уровнях (Read Uncommitted → Serializable).  
NoSQL ради производительности и масштабируемости часто жертвует частью этих гарантий (модель «eventual consistency»).

---

### 3.1*. Преимущества NewSQL‑систем перед SQL и NoSQL


NewSQL объединяет сильные стороны обоих подходов, решая ключевые ограничения:


1. **Масштабируемость + ACID**  
- В отличие от классических SQL, которые масштабируются в основном вертикально (усиление одного сервера), NewSQL поддерживает **горизонтальное масштабирование** (шардинг, кластеры).  
- При этом сохраняются ACID‑гарантии, чего обычно нет в NoSQL (где преобладает «eventual consistency»).


2. **Высокая производительность при транзакционной нагрузке**  
- Оптимизированы для OLTP: тысячи транзакций в секунду на распределённой платформе.  
- Используют in‑memory-вычисления, параллельную обработку, эффективные алгоритмы консенсуса (например, Paxos, Raft).  
- Превосходят традиционные SQL по пропускной способности при росте данных.


3. **Совместимость с SQL и экосистемой**  
- Поддерживают стандартный SQL или его расширенную версию, что упрощает миграцию и разработку.  
- Работают с привычными инструментами (драйверы JDBC/ODBC, ORM, BI).  
- Нет необходимости переписывать приложения под специфичные API NoSQL.

4. **Гибкость развёртывания**  
- Могут работать как на физических серверах, так и в облаке, в контейнерах.  
- Поддерживают гибридные сценарии (часть данных в памяти, часть на диске).  
- Обеспечивают геораспределённость с синхронной/асинхронной репликацией.

5. **Баланс между структурированностью и адаптивностью**  
- Сохраняют реляционную модель и типизацию, но допускают более гибкие схемы, чем классические SQL.  
- Позволяют эволюционировать структуру без полных миграций (в отличие от жёстких ограничений старых SQL‑СУБД).  
- Лучше подходят для микросервисных архитектур, чем монолитные SQL‑системы.


**Примеры NewSQL‑СУБД:** CockroachDB, Google Spanner, VoltDB, MemSQL (SingleStore), NuoDB.


**Итог:**  
- **SQL** — лучший выбор для задач, где критична согласованность и есть чёткая схема.  
- **NoSQL** — для высокомасштабируемых систем с неструктурированными данными и допустимой несогласованностью.  
- **NewSQL** — компромисс: масштабируемость NoSQL + надёжность и SQL‑совместимость классических реляционных СУБД.
### Задание 4

`### Критерии выбора СУБД


Ключевым критерием при выборе СУБД для кластера из 1000 машин становится **масштабируемость** — способность эффективно распределять нагрузку по узлам и наращивать производительность при добавлении ресурсов. Дополнительно учитывают:


- **Тип данных** (структурированные, полуструктурированные, неструктурированные).
- **Характер нагрузок** (OLTP, OLAP, смешанные; объём и частота запросов).
- **Требования к согласованности** (ACID vs eventual consistency).
- **Задержки** (реальное время vs пакетная обработка).
- **Экосистему и инструменты** (интеграция, мониторинг, ETL).
- **Стоимость эксплуатации** (лицензии, железо, администрирование).


### Оптимальная модель распределённых вычислений


Для массивно-параллельных вычислений на 1000 узлах лучше всего подходят **Apache Spark** и **Hadoop MapReduce** — они спроектированы именно для такой задачи.


#### Почему Spark и MapReduce?


1. **Горизонтальное масштабирование**  
   - Система растёт линейно: добавляете узлы — растёт пропускная способность.
   - Данные и вычисления распределяются по всем 1000 машинам, исключая «узкие места».


2. **Отказоустойчивость**  
   - При падении узла задача перераспределяется на другие.
   - Данные реплицируются (HDFS в Hadoop, RDD в Spark), что предотвращает потерю.


3. **Параллелизм на уровне задач**  
   - Вычисления разбиваются на мелкие операции, которые выполняются одновременно на тысячах ядер.
   - Spark дополнительно оптимизирует конвейеры (in‑memory, DAG), сокращая дисковые операции.


4. **Поддержка разнородных данных**  
   - Работают с CSV, JSON, Parquet, Avro, базами данных и т. п.
   - Легко интегрируются с NoSQL (Cassandra, HBase) и SQL‑источниками.


5. **Богатая экосистема**  
   - **Spark**: SQL/DataFrames, MLlib (машинное обучение), GraphX (графы), Structured Streaming (потоки).
   - **Hadoop**: HDFS (хранилище), YARN (оркестрация), Hive (SQL‑надстройка), Pig (скрипты).


6. **Гибкость сценариев**  
   - **Batch‑обработка** (большие отчёты, ETL) — классический use‑case для MapReduce и Spark.
   - **Итеративные алгоритмы** (ML, графы) — Spark эффективнее за счёт кэширования в памяти.
   - **Потоковая обработка** — Spark Streaming или Structured Streaming.


### Какую СУБД выбрать под этот кластер?


Зависит от типа данных и запросов:


1. **Если данные структурированы и нужны сложные SQL‑запросы**  
   - **Distributed SQL** (CockroachDB, YugabyteDB) — масштабируемые ACID‑системы с поддержкой стандартного SQL.
   - **Greenplum** — MPP‑СУБД для аналитики на тысячах узлов.


2. **Если данные полу‑/неструктурированы и важна скорость записи/чтения**  
   - **Cassandra** — высокая доступность, линейное масштабирование, eventual consistency.
   - **MongoDB** — гибкая схема, шардинг, индексы.


3. **Если задача — чистая аналитика больших данных (OLAP)**  
   - **ClickHouse** — колоночное хранение, быстрые агрегации.
   - **Druid** — реальное время, высоконагруженные дашборды.


4. **Если нужны и транзакции, и аналитика**  
   - **NewSQL** (Google Spanner, TiDB) — компромисс между ACID и масштабируемостью.


### Итог


- **Модель вычислений**: **Apache Spark** (предпочтительнее из‑за in‑memory и унифицированной экосистемы) или **Hadoop MapReduce** (для пакетной обработки).
- **СУБД**: выбирают по типу данных и требованиям к согласованности:
  - SQL/ACID → Distributed SQL или Greenplum.
  - NoSQL/масштабирование → Cassandra/MongoDB.
  - Аналитика → ClickHouse/Druid.
  - Гибрид → NewSQL.


**Обоснование**: Spark/MapReduce обеспечивают распараллеливание на 1000 узлов, а выбранная СУБД должна эффективно хранить и предоставлять данные для этих вычислений, не становясь бутылочным горлышком.
